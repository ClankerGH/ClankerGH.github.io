<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ClankerCore™ — under emergence</title>

  <!-- Keep this out of search results -->
  <meta name="robots" content="noindex,nofollow,noarchive" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  <style>
    :root{
      --bg0:#05050a;
      --bg1:#0a0a12;
      --fg:#e9e9f2;
      --muted:rgba(233,233,242,.78);
      --dim:rgba(233,233,242,.35);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; overflow:hidden; }

    body{
      background:
        radial-gradient(1200px 900px at 50% 40%, rgba(255,255,255,.03), transparent 55%),
        radial-gradient(900px 700px at 20% 20%, rgba(90,70,180,.08), transparent 60%),
        radial-gradient(900px 700px at 80% 30%, rgba(40,160,210,.06), transparent 62%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      color:var(--fg);
      font: 16px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
    }

    /* Pressure-seal grain (very light) */
    body::before{
      content:"";
      position:fixed; inset:0;
      pointer-events:none;
      opacity:.12;
      background-image:
        repeating-linear-gradient(0deg, rgba(255,255,255,.06) 0 1px, transparent 1px 3px),
        repeating-linear-gradient(90deg, rgba(255,255,255,.035) 0 1px, transparent 1px 4px);
      mix-blend-mode: overlay;
      filter: blur(.35px);
    }

    canvas{
      position:fixed; inset:0;
      width:100%; height:100%;
      display:block;
      pointer-events:none;
    }

    .lockup{
      position:fixed;
      left: clamp(18px, 3.5vw, 46px);
      bottom: clamp(18px, 3.5vw, 46px);
      z-index: 2;
      user-select:none;
      letter-spacing:.01em;
      text-shadow: 0 10px 30px rgba(0,0,0,.55);
    }

    .title{
      margin:0;
      font-size: clamp(1.05rem, 1.9vw, 1.45rem);
      font-weight: 720;
      color: rgba(233,233,242,.92);
    }

    .subtitle{
      margin:.22rem 0 0 0;
      font-size: clamp(.95rem, 1.5vw, 1.08rem);
      color: var(--muted);
      letter-spacing:.02em;
    }

    /* If someone somehow tabs, don't show broken focus chrome */
    a:focus-visible{ outline: none; }

    @media (prefers-reduced-motion: reduce){
      body::before{ opacity:.08; }
    }
  </style>
</head>

<body>
  <canvas id="field" aria-hidden="true"></canvas>

  <div class="lockup" aria-label="ClankerCore status">
    <p class="title">ClankerCore™</p>
    <p class="subtitle">under emergence</p>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById("field");
    const ctx = canvas.getContext("2d", { alpha: true });

    const prefersReduced = window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;

    // --- Resize / DPR ---
    let W=0, H=0, DPR=1;
    function resize(){
      DPR = Math.min(2, window.devicePixelRatio || 1);
      W = Math.floor(window.innerWidth);
      H = Math.floor(window.innerHeight);
      canvas.width  = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      canvas.style.width = W + "px";
      canvas.style.height = H + "px";
      ctx.setTransform(DPR,0,0,DPR,0,0);
    }
    window.addEventListener("resize", resize, { passive:true });
    resize();

    // --- Cursor "dim light" (no gimmick spotlight, just a reveal bias) ---
    let mx = W * 0.5, my = H * 0.55;
    let hasPointer = false;
    window.addEventListener("pointermove", (e) => {
      hasPointer = true;
      mx = e.clientX; my = e.clientY;
    }, { passive:true });

    // --- Helpers ---
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp = (a,b,t)=>a+(b-a)*t;

    // Hashy noise (fast, not Perlin; good enough for texture)
    function hash2(x,y){
      // deterministic pseudo-random in [0,1)
      const s = Math.sin(x*127.1 + y*311.7) * 43758.5453123;
      return s - Math.floor(s);
    }
    function smoothNoise(x,y){
      const xi = Math.floor(x), yi = Math.floor(y);
      const xf = x - xi, yf = y - yi;
      const u = xf*xf*(3-2*xf);
      const v = yf*yf*(3-2*yf);
      const n00 = hash2(xi,yi);
      const n10 = hash2(xi+1,yi);
      const n01 = hash2(xi,yi+1);
      const n11 = hash2(xi+1,yi+1);
      const nx0 = lerp(n00,n10,u);
      const nx1 = lerp(n01,n11,u);
      return lerp(nx0,nx1,v);
    }

    // --- Core parameters (the "star cursed with earth") ---
    let t = 0;
    let drift = 0;

    // Rare brightening: slow random walk + occasional "pressure spike"
    let pressure = 0.15;      // baseline
    let targetPressure = 0.15;
    let spike = 0;
    let nextSpikeAt = 3 + Math.random()*6; // seconds

    function updatePressure(dt){
      // baseline wandering
      targetPressure += (Math.random() - 0.5) * 0.02;
      targetPressure = clamp(targetPressure, 0.08, 0.22);
      pressure = lerp(pressure, targetPressure, 0.03);

      // spikes (rare, restrained)
      if (!prefersReduced) {
        nextSpikeAt -= dt;
        if (nextSpikeAt <= 0) {
          // small spike, never huge
          spike = 0.10 + Math.random()*0.18;
          nextSpikeAt = 5 + Math.random()*14; // rare-ish
        }
        // spike decays slowly
        spike *= Math.pow(0.86, dt*6);
        if (spike < 0.001) spike = 0;
      } else {
        spike = 0;
      }
    }

    // --- Ø⁺ roaming: faint, random, cursor-biased reveal ---
    const glyphs = [];
    const GLYPH_COUNT = 7; // keep low. subtle.
    function resetGlyph(g){
      g.x = Math.random() * W;
      g.y = Math.random() * H;
      g.life = 0;
      g.onFor = 0.6 + Math.random()*2.2;   // visible duration
      g.offFor = 0.9 + Math.random()*4.5;  // hidden duration
      g.state = "off";
      g.alpha = 0;
      g.size = 18 + Math.random()*22;      // not tiny, but faint
      g.phase = Math.random()*Math.PI*2;
    }
    for(let i=0;i<GLYPH_COUNT;i++){
      const g = {};
      resetGlyph(g);
      g.life = Math.random()*3;
      glyphs.push(g);
    }

    function updateGlyphs(dt){
      for(const g of glyphs){
        g.life += dt;

        // drift slowly
        const dx = Math.cos(g.phase + t*0.08) * 6;
        const dy = Math.sin(g.phase + t*0.06) * 6;
        g.x = (g.x + dx*dt + W) % W;
        g.y = (g.y + dy*dt + H) % H;

        if (g.state === "off"){
          g.alpha = lerp(g.alpha, 0, 0.08);
          if (g.life > g.offFor){
            g.state = "on";
            g.life = 0;
            g.onFor = 0.45 + Math.random()*1.8;
            g.phase = Math.random()*Math.PI*2;
          }
        } else {
          // on
          // base faintness (almost too faint)
          const base = 0.03 + Math.random()*0.02;

          // cursor reveal bias (dim light): stronger if near pointer, but still subtle
          let reveal = 0;
          if (hasPointer){
            const d = Math.hypot(g.x - mx, g.y - my);
            // reveal range is modest; it should feel like "maybe I saw something"
            reveal = clamp(1 - d / 170, 0, 1) * 0.10;
          }

          // a tiny flicker so it's never a flat stamp
          const flick = (Math.sin((t*2.2) + g.phase) * 0.5 + 0.5) * 0.015;

          const targetA = base + reveal + flick;
          g.alpha = lerp(g.alpha, targetA, 0.10);

          if (g.life > g.onFor){
            g.state = "off";
            g.life = 0;
            g.offFor = 1.0 + Math.random()*6.0;
            // occasionally "teleport" so it feels like it's elsewhere
            if (Math.random() < 0.55){
              g.x = Math.random()*W;
              g.y = Math.random()*H;
            }
          }
        }
      }
    }

    // --- Rendering ---
    function draw(dt){
      t += dt;
      drift += dt * 0.06;

      updatePressure(dt);
      updateGlyphs(dt);

      // Clear with transparent black (let CSS background breathe)
      ctx.clearRect(0,0,W,H);

      // FIELD: subtle vignetting + micro variance
      const vign = ctx.createRadialGradient(W*0.5, H*0.55, Math.min(W,H)*0.1, W*0.5, H*0.55, Math.max(W,H)*0.75);
      vign.addColorStop(0, "rgba(0,0,0,0)");
      vign.addColorStop(1, "rgba(0,0,0,0.55)");
      ctx.fillStyle = vign;
      ctx.fillRect(0,0,W,H);

      // CORE: implied heat under dense matter (no obvious lava)
      const cx = W * 0.52;
      const cy = H * 0.48;
      const r  = Math.min(W,H) * 0.22;

      // Shape distortion via noise sampling
      // We'll render a soft-edged mass by painting layered gradients + noise masks.
      const layers = 5;
      for (let i=0;i<layers;i++){
        const k = i/(layers-1);
        const rr = r * (1.10 - k*0.18);
        const ox = (smoothNoise(drift*2 + i*7, 3.1) - 0.5) * 18;
        const oy = (smoothNoise(1.7, drift*2 + i*9) - 0.5) * 18;

        // Heat is pressure + spike, but bounded
        const heat = clamp(pressure + spike*0.7, 0.06, 0.40);

        // Inner glow color: warm-white core, but very restrained
        const a = (0.055 + heat*0.10) * (1 - k*0.75);
        const g = ctx.createRadialGradient(cx+ox, cy+oy, rr*0.06, cx+ox, cy+oy, rr);
        // Center never becomes "bright"
        g.addColorStop(0.0, `rgba(255,245,235,${a*0.85})`);
        g.addColorStop(0.22, `rgba(255,170,120,${a*0.28})`);
        g.addColorStop(0.55, `rgba(150,90,170,${a*0.14})`);
        g.addColorStop(1.0, `rgba(0,0,0,0)`);

        ctx.globalCompositeOperation = "lighter";
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.ellipse(cx+ox, cy+oy, rr*1.05, rr*0.86, (smoothNoise(drift, i*11)-0.5)*0.25, 0, Math.PI*2);
        ctx.fill();
      }

      // Dense shell (the "earth"): dark mass that contains the glow
      ctx.globalCompositeOperation = "source-over";
      const shell = ctx.createRadialGradient(cx, cy, r*0.12, cx, cy, r*1.25);
      shell.addColorStop(0.0, "rgba(10,10,18,0)");
      shell.addColorStop(0.35, "rgba(10,10,18,0.16)");
      shell.addColorStop(0.72, "rgba(5,5,10,0.72)");
      shell.addColorStop(1.0, "rgba(0,0,0,0)");
      ctx.fillStyle = shell;
      ctx.beginPath();
      ctx.ellipse(cx, cy, r*1.18, r*0.98, 0, 0, Math.PI*2);
      ctx.fill();

      // Micro texture over the core area (subtle, not noisy)
      const texCount = prefersReduced ? 0 : 220;
      ctx.globalCompositeOperation = "overlay";
      ctx.fillStyle = "rgba(255,255,255,0.015)";
      for(let i=0;i<texCount;i++){
        const ang = Math.random()*Math.PI*2;
        const rad = Math.random()*r*1.05;
        const px = cx + Math.cos(ang)*rad;
        const py = cy + Math.sin(ang)*rad;
        const s  = 0.6 + Math.random()*1.7;
        ctx.fillRect(px, py, s, s);
      }

      // Ø⁺ glyphs
      ctx.globalCompositeOperation = "screen";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for(const g of glyphs){
        if (g.alpha <= 0.002) continue;

        // Slightly "ghosted" rendering
        const a = clamp(g.alpha, 0, 0.18);
        ctx.font = `${Math.round(g.size)}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        ctx.fillStyle = `rgba(233,233,242,${a})`;
        ctx.fillText("Ø⁺", g.x, g.y);

        // faint twin offset (gives texture, not readability)
        ctx.fillStyle = `rgba(120,90,220,${a*0.25})`;
        ctx.fillText("Ø⁺", g.x+1.2, g.y+0.8);
      }

      ctx.globalCompositeOperation = "source-over";
      // Final pressure seal vignette (keeps everything contained)
      const seal = ctx.createRadialGradient(cx, cy, r*0.2, cx, cy, Math.max(W,H)*0.9);
      seal.addColorStop(0.0, "rgba(0,0,0,0)");
      seal.addColorStop(0.55, "rgba(0,0,0,0.10)");
      seal.addColorStop(1.0, "rgba(0,0,0,0.62)");
      ctx.fillStyle = seal;
      ctx.fillRect(0,0,W,H);
    }

    // --- Animation loop (throttled) ---
    let last = performance.now();
    let acc = 0;
    const FPS = prefersReduced ? 2 : 24;
    const step = 1 / FPS;

    function loop(now){
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;
      acc += dt;

      while(acc >= step){
        draw(step);
        acc -= step;
      }
      requestAnimationFrame(loop);
    }

    // Start after first paint
    requestAnimationFrame((n) => {
      last = n;
      requestAnimationFrame(loop);
    });
  })();
  </script>
</body>
</html>
